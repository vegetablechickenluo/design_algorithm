# <div align = "center">**算法设计第一次作业**</div>

### *2_7* 

**Answer**:

由已知条件得，算法可在 *O(i logi)* 时间内计算两个 *i* 次多项式的乘积。

且原式可表示为：
$$
P(x)\ = \ (x-n_1)(x-n_2)...(x-n_d)
$$
则由分治思想，可将 *d* 次多项式转换为2个 *d/2* 次多项式的乘积，则可设计算 *d* 次多项式的时间为 T(*d*)，则可表示为：
$$
T(d) =  \left\{
				\begin{array}{**lr**}
				\ O(1) , &d = 1 \\\
				2T(d / 2) + O(d\ logd), &d > 1
				\end{array}
\right.
$$
则对此递归求解即可得:
$$
T(d) = O(d log^2d ).
$$

### *2_9*

**Answer：**

将此题解释即可分析出，此题希望求出函数一个解所占的整个解空间的规模大于一半，即可称为主元素。

则由此可得出结论， x 必为排好序的数组T的中位数。

易证明：

*S(x) > n /2* 时，则按照序关系排好后，必有中位数被主元素占据。

则只需要在线性时间中找出数组的中位数，再遍历查看中位数是否与主元素相同即可。则复杂度应为*O(n)*

详情代码可见本人的github网址：(https://github.com/vegetablechickenluo/design_algorithm/blob/master/work2_9/main.cpp)

**输出样例：**

~~~ C++
请输入数组长度n: 5
请输入依次输入n个数： 2 3 4 4 3
不存在

请输入数组长度n: 3
请输入依次输入n个数： 1 1 2
存在

请输入数组长度n: 6
请输入依次输入n个数： 4 3 3 4 4 4
存在

~~~

此题易得出：时间复杂度为 *O(n)*

### *2_10*

**Answer:**

由于此题目中数组 **T** 的元素不再具有序关系，因此不可以用 *2_9* 中线性时间寻找中位数的方法去寻找。

换用二分的思想来尝试解决该问题，假设[0 : (n - 1) /2] 部分与[(n - 1) / 2 : (n - 1)] 部分的主元素不为x，则合并后的整个数组的主元素不为x。因此，可以采用二分的思想来解决该问题。

则算法的递归式表示为：
$$
T(n) = 2 T(n / 2) + O(n)
$$
由《算法导论》中的主定理，易求出算法复杂度下界为：*O(n logn)*

详情代码可见本人的github网址——*由于此题数组设定为无序，则不会采用比较的方式*：

（）





